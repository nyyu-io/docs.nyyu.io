import defaults from 'defaults';
import { EventSourceParserStream } from 'eventsource-parser/stream';
import mergeWith from 'lodash-es/mergeWith.js';
import { DEFAULT_OPTIONS } from './index.js';
import { isChatCompletion, isChatCompletionChunk, isChatCompletionMessage, isMarkpromptMetadata, isNoStreamingData, parseEncodedJSONHeader, } from './utils.js';
export const DEFAULT_SUBMIT_CHAT_OPTIONS = {
    frequencyPenalty: 0,
    iDontKnowMessage: 'Sorry, I am not sure how to answer that.',
    model: 'gpt-4o',
    presencePenalty: 0,
    temperature: 0.1,
    topP: 1,
    stream: true,
    outputFormat: 'markdown',
};
const validSubmitChatOptionsKeys = [
    'assistantId',
    'assistantVersionId',
    'apiUrl',
    'allowFollowUpQuestions',
    'context',
    'debug',
    'doNotInjectContext',
    'excludeFromInsights',
    'frequencyPenalty',
    'iDontKnowMessage',
    'jsonOutput',
    'maxTokens',
    'model',
    'outputFormat',
    'policiesOptions',
    'presencePenalty',
    'redact',
    'retrievalOptions',
    'sectionsMatchCount',
    'sectionsMatchThreshold',
    'stream',
    'systemPrompt',
    'temperature',
    'threadId',
    'toolChoice',
    'tools',
    'topP',
];
const isValidSubmitChatOptionsKey = (key) => {
    return validSubmitChatOptionsKeys.includes(key);
};
function checkAbortSignal(signal) {
    if (signal?.aborted) {
        if (signal.reason instanceof Error) {
            throw signal.reason;
        }
        throw new Error(signal.reason);
    }
}
export async function* submitChat(messages, projectKey, options = {}) {
    if (!projectKey) {
        throw new Error('A projectKey is required.');
    }
    if (!messages || !Array.isArray(messages) || messages.length === 0) {
        return;
    }
    const validOptions = Object.fromEntries(Object.entries(options).filter(([key]) => isValidSubmitChatOptionsKey(key)));
    const { signal, tools, toolChoice, ...cloneableOpts } = validOptions;
    const { debug, policiesOptions, retrievalOptions, ...resolvedOptions } = defaults({
        ...cloneableOpts,
        // only include known tool properties
        tools: tools?.map((tool) => ({
            function: tool.function,
            type: tool.type,
        })),
        toolChoice: toolChoice,
    }, { ...DEFAULT_OPTIONS, ...DEFAULT_SUBMIT_CHAT_OPTIONS });
    const res = await fetch(`${resolvedOptions.apiUrl}/chat`, {
        method: 'POST',
        headers: new Headers({
            'Content-Type': 'application/json',
            'X-Markprompt-API-Version': '2023-12-01',
        }),
        body: JSON.stringify({
            projectKey,
            messages,
            debug,
            ...resolvedOptions,
            policies: policiesOptions,
            retrieval: retrievalOptions,
        }),
        signal,
    });
    const data = parseEncodedJSONHeader(res, 'x-markprompt-data');
    checkAbortSignal(options.signal);
    if (res.headers.get('Content-Type')?.includes('application/json')) {
        const json = await res.json();
        if (isChatCompletion(json) &&
            isMarkpromptMetadata(data) &&
            json.choices[0]) {
            return { ...json.choices[0].message, ...data };
        }
        else {
            if (isMarkpromptMetadata(data)) {
                yield data;
            }
            if (isNoStreamingData(json)) {
                yield {
                    content: json.text,
                    references: json.references,
                    role: 'assistant',
                };
                return;
            }
            throw new Error('Malformed response from Markprompt API', {
                cause: json,
            });
        }
    }
    if (isMarkpromptMetadata(data)) {
        yield data;
    }
    if (!res.ok || !res.body) {
        checkAbortSignal(options.signal);
        const text = await res.text();
        try {
            const json = JSON.parse(text);
            if (json.error) {
                throw new Error(json.error);
            }
        }
        catch (e) {
            // ignore
        }
        throw new Error(text);
    }
    checkAbortSignal(options.signal);
    // eslint-disable-next-line prefer-const
    let completion = {};
    const stream = res.body
        .pipeThrough(new TextDecoderStream())
        .pipeThrough(new EventSourceParserStream())
        .getReader();
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const { value: event, done } = await stream.read();
        if (done)
            break;
        if (!event)
            continue;
        if (event.data === '[DONE]') {
            continue;
        }
        // eslint-disable-next-line prefer-const
        let json = JSON.parse(event.data);
        if (!isChatCompletionChunk(json)) {
            throw new Error('Malformed response from Markprompt API', {
                cause: json,
            });
        }
        mergeWith(completion, json.choices[0]?.delta, concatStrings);
        checkAbortSignal(options.signal);
        /**
         * If we do not yield a structuredClone here, the completion object will
         * become read-only/frozen and TypeErrors will be thrown when trying to
         * merge the next chunk into it.
         */
        yield structuredClone(completion);
    }
    checkAbortSignal(options.signal);
    if (isChatCompletionMessage(completion) && isMarkpromptMetadata(data)) {
        return { ...completion, ...data };
    }
}
function concatStrings(dest, src) {
    if (typeof dest === 'string' && typeof src === 'string') {
        return dest + src;
    }
    return undefined;
}
//# sourceMappingURL=chat.js.map