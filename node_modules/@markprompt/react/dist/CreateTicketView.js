import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { autoUpdate, flip, offset, shift, useFloating, } from '@floating-ui/react-dom';
import clsx from 'clsx';
import { useSelect } from 'downshift';
import { useId, useMemo, useRef, useState, } from 'react';
import { toValidApiMessages } from './chat/utils.js';
import { ChevronDownIcon, ChevronLeftIcon, LoadingIcon } from './icons.js';
import { useChatStore } from './index.js';
import { useGlobalStore } from './store.js';
export function CreateTicketView(props) {
    const { handleGoBack, includeNav, includeCTA } = props;
    const form = useRef(null);
    const createTicketOptions = useGlobalStore((state) => state.options.integrations?.createTicket);
    const projectKey = useGlobalStore((state) => state.options.projectKey);
    const threadId = useChatStore((state) => state.threadId);
    const apiUrl = useGlobalStore((state) => state.options?.apiUrl);
    const summary = useGlobalStore((state) => threadId ? state.tickets?.summaryByThreadId[threadId] : undefined);
    const messages = useChatStore((state) => state.messages);
    const [totalFileSize, setTotalFileSize] = useState(0);
    const [result, setResult] = useState();
    const [error, setError] = useState();
    const [isSubmittingCase, setSubmittingCase] = useState(false);
    const provider = createTicketOptions?.provider;
    const handleSubmit = async (event) => {
        event.preventDefault();
        if (!apiUrl ||
            !projectKey ||
            !provider ||
            !event.currentTarget.email.value ||
            !event.currentTarget.userName.value ||
            !event.currentTarget.summary.value) {
            return;
        }
        setResult(undefined);
        setSubmittingCase(true);
        try {
            const data = new FormData(event.currentTarget);
            // copy a field for legacy reasons
            const result = await fetch(`${apiUrl}/integrations/create-ticket`, {
                method: 'POST',
                // don't pass a Content-Type header here, the browser will
                // generate a correct header which includes the boundary.
                body: data,
            });
            setSubmittingCase(false);
            setResult(result);
            setTotalFileSize(0);
            setError(undefined);
            form.current?.reset();
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.error(error);
            setSubmittingCase(false);
            setResult(undefined);
            setTotalFileSize(0);
            if (error instanceof Error) {
                setError(error);
            }
            else {
                setError(new Error('Something went wrong while submitting your case', {
                    cause: error,
                }));
            }
        }
    };
    const description = useMemo(() => {
        if (!messages || messages.length === 0) {
            return '';
        }
        const transcript = toValidApiMessages(messages)
            .map((m) => {
            return `${m.role === 'user' ? 'Me' : 'AI'}: ${m.content}`;
        })
            .join('\n\n');
        return `${summary?.content || ''}\n\n---\n\nFull transcript:\n\n${transcript}`;
    }, [summary?.content, messages]);
    return (_jsxs("div", { className: "MarkpromptCreateTicketView", children: [includeNav ? (_jsx("div", { className: "MarkpromptChatViewNavigation", children: _jsx("button", { className: "MarkpromptGhostButton", onClick: handleGoBack, children: _jsx(ChevronLeftIcon, { style: { width: 16, height: 16 }, strokeWidth: 2.5 }) }) })) : (_jsx("div", {})), _jsx("div", { className: "MarkpromptCreateTicket", children: _jsxs("form", { onSubmit: handleSubmit, className: "MarkpromptCreateTicketForm", ref: form, children: [_jsx("input", { type: "hidden", name: "projectKey", value: projectKey }), _jsx("input", { type: "hidden", name: "provider", value: provider }), _jsxs("div", { className: "MarkpromptFormGroup", children: [_jsx("label", { htmlFor: "userName", children: createTicketOptions?.form?.nameLabel || 'Name' }), _jsx("input", { required: true, type: "text", id: "userName", name: "userName", value: createTicketOptions?.user?.name, readOnly: !!createTicketOptions?.user?.name, disabled: isSubmittingCase, placeholder: createTicketOptions?.form?.namePlaceholder })] }), _jsxs("div", { className: "MarkpromptFormGroup", children: [_jsx("label", { htmlFor: "email", children: createTicketOptions?.form?.emailLabel || 'Email' }), _jsx("input", { required: true, type: "email", id: "email", name: "email", value: createTicketOptions?.user?.email, readOnly: !!createTicketOptions?.user?.email, disabled: isSubmittingCase, placeholder: createTicketOptions?.form?.emailPlaceholder })] }), _jsxs("div", { className: "MarkpromptFormGroup MarkpromptFormGroupGrow", children: [_jsx("label", { htmlFor: "summary", id: "summary-label", children: createTicketOptions?.form?.summaryLabel || 'Description' }), _jsx("textarea", { name: "summary", id: "summary", value: description, placeholder: summary?.state &&
                                        summary.state !== 'done' &&
                                        summary?.state !== 'cancelled'
                                        ? createTicketOptions?.form?.summaryLoading
                                        : createTicketOptions?.form?.summaryPlaceholder, required: true, "aria-labelledby": "summary-label", disabled: isSubmittingCase, style: {
                                        color: summary?.state &&
                                            summary.state !== 'done' &&
                                            summary?.state !== 'cancelled'
                                            ? 'var(--markprompt-mutedForeground)'
                                            : 'var(--markprompt-foreground)',
                                    } })] }), createTicketOptions?.form?.customFields &&
                            createTicketOptions?.form?.customFields.map((field) => (_jsx(CustomFieldSelect, { customField: field }, field.id))), createTicketOptions?.form?.hasFileUploadInput && (_jsxs("div", { className: "MarkpromptFormGroup", children: [_jsx("label", { htmlFor: "files", children: createTicketOptions?.form?.uploadFileLabel || 'Attach a file' }), _jsx("input", { type: "file", name: "files", id: "files", disabled: isSubmittingCase, onChange: (event) => {
                                        const files = event.currentTarget.files;
                                        if (!files)
                                            return;
                                        let _totalFileSize = 0;
                                        for (const file of files) {
                                            _totalFileSize += file.size / 1024 ** 2; // file size in MB
                                        }
                                        setTotalFileSize(_totalFileSize);
                                    }, multiple: true }), totalFileSize >= 4.5 && (_jsx("p", { className: "MarkpromptTicketViewFormGroupMessage", children: createTicketOptions?.form?.maxFileSizeError }))] })), includeCTA && (_jsxs("div", { className: "MarkpromptTicketViewButtonRow", children: [_jsxs("div", { children: [result && (_jsx("p", { className: "MarkpromptTicketViewButtonRowMessage", children: result.ok
                                                ? createTicketOptions?.form?.ticketCreatedOk
                                                : createTicketOptions?.form?.ticketCreatedError })), error && (_jsx("p", { className: "MarkpromptTicketViewButtonRowMessage", children: createTicketOptions?.form?.ticketCreatedError }))] }), _jsxs("button", { type: "submit", className: "MarkpromptButton", "data-variant": "primary", disabled: isSubmittingCase || totalFileSize >= 4.5, children: [createTicketOptions?.form?.submitLabel || 'Send message', isSubmittingCase && (_jsx(LoadingIcon, { style: { width: 16, height: 16 } }))] })] }))] }) })] }));
}
function CustomFieldSelect(props) {
    const { customField } = props;
    // refactor this to use flatMap instead of reduce
    const flatItems = useMemo(() => customField.items.flatMap((x) => ('items' in x ? x.items : x)), [customField.items]);
    const { isOpen, selectedItem, getToggleButtonProps, getMenuProps, highlightedIndex, getItemProps, } = useSelect({
        items: flatItems,
    });
    const { refs, floatingStyles } = useFloating({
        open: isOpen,
        placement: 'bottom-start',
        middleware: [offset(8), flip(), shift()],
        whileElementsMounted: autoUpdate,
    });
    const id = useId();
    return (_jsxs("div", { className: "MarkpromptFormGroup", style: isOpen ? { zIndex: 10 } : {}, children: [_jsx("label", { htmlFor: `custom_field_${id}`, children: customField.label }), _jsx("input", { type: "hidden", id: `custom_field_${id}`, name: "customFields", value: selectedItem
                    ? JSON.stringify({ id: customField.id, value: selectedItem.value })
                    : undefined }), _jsxs("div", { className: "MarkpromptSelect", children: [_jsxs("button", { type: "button", className: clsx('MarkpromptSelectToggle', 'MarkpromptSelectToggleWithIcon', { MarkpromptSelectToggleMuted: !selectedItem }), ...getToggleButtonProps({ ref: refs.setReference }), children: [selectedItem?.label || 'Selectâ€¦', ' ', _jsx(ChevronDownIcon, { width: 16, height: 16, "aria-hidden": true })] }), _jsx("ul", { ...getMenuProps({ ref: refs.setFloating }), className: "MarkpromptSelectMenu", "data-open": isOpen, style: floatingStyles, children: customField.items.map((item) => {
                            if ('items' in item) {
                                return (_jsxs("li", { children: [_jsx("strong", { className: "MarkpromptSelectGroupLabel", children: item.label }), _jsx("ul", { children: item.items.map((option) => (_jsx("li", { ...getItemProps({ item: option }), "data-highlighted": highlightedIndex === flatItems.indexOf(option), children: option.label }, option.value))) })] }, item.label));
                            }
                            else {
                                return (_jsx("li", { ...getItemProps({ item }), "data-highlighted": highlightedIndex === flatItems.indexOf(item), children: item.label }, item.value));
                            }
                        }) })] })] }));
}
export function CustomCaseFormRenderer(props) {
    const { CustomCaseForm } = props;
    const messages = useChatStore((state) => state.messages);
    const threadId = useChatStore((state) => state.threadId);
    const summary = useGlobalStore((state) => threadId ? state.tickets?.summaryByThreadId[threadId] : undefined);
    const description = useMemo(() => {
        if (!messages || messages.length === 0) {
            return '';
        }
        const transcript = toValidApiMessages(messages)
            .map((m) => {
            return `${m.role === 'user' ? 'Me' : 'AI'}: ${m.content}`;
        })
            .join('\n\n');
        return `${summary?.content || ''}\n\n---\n\nFull transcript:\n\n${transcript}`;
    }, [summary?.content, messages]);
    return _jsx(CustomCaseForm, { summary: description });
}
//# sourceMappingURL=CreateTicketView.js.map