import { Fragment as _Fragment, jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import {} from '@markprompt/core';
import { AccessibleIcon } from '@radix-ui/react-accessible-icon';
import { useCallback, useMemo } from 'react';
import {} from './store.js';
import { CheckCircleIcon, CircleDashedIcon, CrossCircleIcon, LoaderIcon, } from '../icons.js';
export function DefaultToolCallsConfirmation(props) {
    const { toolCalls, tools, toolCallsStatus, confirmToolCalls } = props;
    const toolCallsRequiringConfirmation = useMemo(() => {
        return toolCalls.filter((toolCall) => {
            const tool = tools?.find((tool) => tool.tool.function.name === toolCall.function?.name);
            if (!tool) {
                // Skip tools that are in the messages but no longer in the
                // config.
                return false;
            }
            return tool?.requireConfirmation ?? true;
        });
    }, [toolCalls, tools]);
    const toolCallsWithoutConfirmationAndWithMessage = useMemo(() => {
        return toolCalls.filter((toolCall) => {
            const tool = tools?.find((tool) => {
                const show = typeof tool.showDefaultAutoTriggerMessage === 'undefined'
                    ? true
                    : tool.showDefaultAutoTriggerMessage;
                return tool.tool.function.name === toolCall.function?.name && show;
            });
            return tool?.requireConfirmation === false;
        });
    }, [toolCalls, tools]);
    const getStatusIcon = useCallback((status) => {
        switch (status) {
            case 'loading':
                return LoaderIcon;
            case 'done':
                return CheckCircleIcon;
            case 'error':
                return CrossCircleIcon;
            default:
                return CircleDashedIcon;
        }
    }, []);
    const showConfirmButton = useMemo(() => {
        const validEntries = Object.entries(toolCallsStatus).filter(([key]) => {
            return toolCallsRequiringConfirmation.some((toolCall) => toolCall.id === key);
        });
        if (validEntries.length === 0)
            return true;
        return validEntries.some(([_key, value]) => value.status !== 'done');
    }, [toolCallsRequiringConfirmation, toolCallsStatus]);
    const hasToolsCallsWithMessages = toolCallsWithoutConfirmationAndWithMessage.length > 0 ||
        toolCallsRequiringConfirmation.length > 0;
    if (!hasToolsCallsWithMessages) {
        return _jsx(_Fragment, {});
    }
    return (_jsxs("div", { className: "MarkpromptToolCallConfirmation", children: [toolCallsWithoutConfirmationAndWithMessage.length > 0 && (_jsxs("div", { children: [_jsx("p", { children: "The bot is calling the following tools on your behalf:" }), toolCallsWithoutConfirmationAndWithMessage.map((toolCall) => {
                        const tool = tools?.find((tool) => tool.tool.function.name === toolCall.function?.name);
                        if (!tool)
                            throw Error('tool not found');
                        const status = toolCallsStatus[toolCall.id]?.status;
                        const StatusIcon = getStatusIcon(status);
                        return (_jsxs("p", { className: "MarkpromptToolDescriptionWithStatus", children: [_jsx(AccessibleIcon, { label: `Tool status: ${status ?? 'not started'}`, children: _jsx(StatusIcon, { width: 16, height: 16, className: `MarkpromptToolCallStatusIcon` }) }), _jsxs("strong", { children: [tool.tool.function.description ?? tool.tool.function.name, ' '] })] }, toolCall.function.name));
                    })] })), toolCallsRequiringConfirmation.length > 0 && (_jsxs(_Fragment, { children: [_jsxs("div", { children: [_jsxs("p", { children: ["The bot wants to perform the following", ' ', toolCalls.length === 1 ? 'action' : 'actions', ", please confirm that you allow to:"] }), toolCallsRequiringConfirmation.map((toolCall) => {
                                const tool = tools?.find((tool) => tool.tool.function.name === toolCall.function?.name);
                                if (!tool)
                                    throw Error('tool not found');
                                const status = toolCallsStatus[toolCall.id]?.status;
                                const StatusIcon = getStatusIcon(status);
                                return (_jsxs("p", { className: "MarkpromptToolDescriptionWithStatus", children: [_jsx(AccessibleIcon, { label: `Tool status: ${status ?? 'not started'}`, children: _jsx(StatusIcon, { width: 16, height: 16, className: `MarkpromptToolCallStatusIcon` }) }), _jsxs("strong", { children: [tool.tool.function.description ?? tool.tool.function.name, ' '] })] }, toolCall.function.name));
                            })] }), showConfirmButton && (_jsx("div", { children: _jsx("button", { className: "MarkpromptButton", "data-variant": "outline", onClick: confirmToolCalls, children: "Confirm" }) }))] }))] }));
}
//# sourceMappingURL=DefaultToolCallsConfirmation.js.map