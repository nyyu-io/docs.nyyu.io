import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useContext, useEffect, useRef, useState, useMemo, } from 'react';
import { ChatContext, useChatStore } from './store.js';
import { ThreadSelect } from './ThreadSelect.js';
import { LoadingIcon, SendIcon } from '../icons.js';
import * as BaseMarkprompt from '../primitives/headless.js';
function ChatSendIcon(props) {
    if (props.isLoading) {
        return (_jsx("div", { children: _jsx(LoadingIcon, {}) }));
    }
    return _jsx(SendIcon, {});
}
export function ChatViewForm(props) {
    const { activeView, chatOptions, minInputRows, submitOnEnter } = props;
    const [prompt, setPrompt] = useState('');
    const submitChat = useChatStore((state) => state.submitChat);
    const lastMessageState = useChatStore((state) => state.messages[state.messages.length - 1]?.state);
    const formRef = useRef(null);
    const textAreaRef = useRef(null);
    const handleSubmit = useCallback((event) => {
        event.preventDefault();
        textAreaRef.current?.blur();
        const data = new FormData(event.currentTarget);
        const value = data.get('markprompt-prompt');
        if (typeof value === 'string') {
            submitChat([{ role: 'user', content: value }]);
        }
        if (event.target instanceof HTMLFormElement) {
            setPrompt('');
        }
    }, [submitChat]);
    useEffect(() => {
        // Bring form input in focus when activeView changes.
        textAreaRef.current?.focus();
    }, [activeView]);
    // keep abortChat up to date, but do not trigger rerenders (and effect hooks calls) when it updates
    const store = useContext(ChatContext);
    const abortChat = useRef(() => store?.getState().abort?.());
    useEffect(() => store?.subscribe((state) => {
        abortChat.current = () => state.abort?.();
    }), [store]);
    useEffect(() => {
        // cancel pending chat requests when the view changes.
        if (activeView && activeView !== 'chat') {
            abortChat.current?.();
        }
        // Cancel pending chat request when the component unmounts.
        return () => abortChat.current?.();
    }, [activeView]);
    const isLoading = useMemo(() => {
        return (lastMessageState === 'streaming-answer' ||
            lastMessageState === 'indeterminate' ||
            lastMessageState === 'preload');
    }, [lastMessageState]);
    const didAcceptDisclaimer = useChatStore((state) => state.didAcceptDisclaimer);
    return (_jsx(BaseMarkprompt.Form, { ref: formRef, className: "MarkpromptForm", onSubmit: handleSubmit, "data-state": !didAcceptDisclaimer ? 'disabled' : undefined, children: _jsxs("div", { className: "MarkpromptPromptWrapper", children: [_jsx(BaseMarkprompt.Prompt, { ref: textAreaRef, className: "MarkpromptPrompt", name: "markprompt-prompt", type: "text", autoFocus: true, placeholder: chatOptions?.placeholder, labelClassName: "MarkpromptPromptLabel", textAreaContainerClassName: "MarkpromptTextAreaContainer", sendButtonClassName: "MarkpromptButton", buttonLabel: isLoading ? 'Generating...' : chatOptions?.buttonLabel, value: prompt, isLoading: isLoading, onChange: (event) => setPrompt(event.target.value), Icon: _jsx(ChatSendIcon, { isLoading: isLoading }), disabled: !didAcceptDisclaimer, minRows: minInputRows, submitOnEnter: submitOnEnter, onSubmit: (e) => {
                        e.preventDefault();
                        formRef.current?.requestSubmit();
                    } }), chatOptions.history && (_jsx(ThreadSelect, { disabled: !didAcceptDisclaimer })), _jsx("div", {})] }) }));
}
//# sourceMappingURL=ChatViewForm.js.map