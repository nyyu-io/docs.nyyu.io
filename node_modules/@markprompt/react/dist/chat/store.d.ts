import { type ChatCompletionMessageToolCall, type ChatCompletionTool, type SubmitChatOptions, type SubmitChatYield, type ChatCompletionChunk } from '@markprompt/core';
import { type ReactNode } from 'react';
import type { MarkpromptOptions } from '../types.js';
export type ChatLoadingState = 'indeterminate' | 'preload' | 'streaming-answer' | 'done' | 'cancelled';
export interface ToolCall {
    status: 'loading' | 'done' | 'error';
    error?: string;
    result?: string;
}
export interface ChatViewMessage extends Omit<SubmitChatYield, 'threadId'> {
    /**
     * Message id.
     */
    id: ReturnType<typeof crypto.randomUUID>;
    /**
     * The loading state.
     */
    state: ChatLoadingState;
    /**
     * Message name.
     */
    name?: string;
    /**
     * Error associated to the message.
     */
    error?: Error;
}
export interface ConfirmationProps {
    /**
     * Tool calls as returned by the model
     */
    toolCalls: ChatCompletionMessageToolCall[];
    /**
     * Status and results of tool calls
     */
    toolCallsStatus: {
        [key: string]: ToolCall;
    };
    /**
     * Tools as provided by the user
     */
    tools?: ChatViewTool[];
    confirmToolCalls: () => void;
}
export interface ChatViewTool {
    /**
     * OpenAI tool definition.
     */
    tool: ChatCompletionTool;
    /**
     * The actual function to call. Called with a JSON string as returned from
     * OpenAI. Should validate the JSON for correctness as OpenAI can hallucinate
     * arguments. Must return a string to feed the result back into OpenAI.
     **/
    call: (args: string) => Promise<string>;
    /**
     * Whether user needs to confirm a call to this function or function calls
     * will be executed right away.
     * @default true
     */
    requireConfirmation?: boolean;
    /**
     * If true, show a message when the tool is automatically triggered.
     * @default true
     */
    showDefaultAutoTriggerMessage?: boolean;
}
export interface ToolsOptions {
    /**
     * A list of tool definitions.
     */
    tools?: ChatViewTool[];
    /**
     * An optional user-provided confirmation message component that takes the
     * tool calls provided by OpenAI and a confirm function that should be called
     * when the user confirms the tool calls.
     */
    ToolCallsConfirmation?: (props: ConfirmationProps) => JSX.Element;
}
export type UserConfigurableOptions = Omit<SubmitChatOptions, 'signal' | 'tools'> & ToolsOptions;
export type SubmitChatMessage = {
    content: string;
    role: 'user';
    name?: string;
} | {
    role: 'assistant';
    tool_calls: ChatCompletionChunk.Choice.Delta.ToolCall[];
} | {
    content: string;
    role: 'tool';
    name: string;
    tool_call_id: string;
};
export interface ThreadData {
    lastUpdated: string;
    messages: ChatViewMessage[];
}
export interface ChatStoreState {
    /**
     * The project key associated to the project.
     **/
    projectKey: string;
    /**
     * The base API URL.
     **/
    apiUrl?: string;
    /**
     * Abort handler.
     **/
    abort?: () => void;
    /**
     * The current thread id.
     **/
    threadId?: string;
    /**
     * Set a thread id.
     **/
    setThreadId: (threadId: string) => void;
    /**
     * Select a thread.
     **/
    selectThread: (threadId?: string) => void;
    /**
     * The messages in the current thread.
     **/
    messages: ChatViewMessage[];
    /**
     * Set messages.
     **/
    setMessages: (messages: ChatViewMessage[]) => void;
    /**
     * Set a message by id.
     **/
    setMessageById(id: string, next: Partial<ChatViewMessage>): void;
    /**
     * Set a message by index.
     **/
    setMessageByIndex: (index: number, next: Partial<ChatViewMessage>) => void;
    /**
     * Set a tool call by id.
     **/
    setToolCallById: (toolCallId: string, next: Partial<ToolCall>) => void;
    /**
     * Dictionary of threads by project id.
     **/
    threadIdsByProjectKey: {
        [projectKey: string]: string[];
    };
    /**
     * Dictionary of messages by thread id.
     **/
    messagesByThreadId: {
        [threadId: string]: ThreadData;
    };
    /**
     * Dictionary of tool calls by id.
     **/
    toolCallsByToolCallId: {
        [tool_call_id: string]: ToolCall;
    };
    /**
     * Submit a list of new messages.
     **/
    submitChat: (messages: SubmitChatMessage[]) => void;
    /**
     * Submit tool calls.
     **/
    submitToolCalls: (message: ChatViewMessage) => Promise<void>;
    /**
     * User configurable chat options.
     **/
    options?: MarkpromptOptions['chat'];
    /**
     * Set the chat options for this session.
     **/
    setOptions: (options: UserConfigurableOptions) => void;
    /**
     * Dictionary of disclaimer acceptance by project id.
     **/
    didAcceptDisclaimerByProjectKey: {
        [projectKey: string]: boolean;
    };
    /**
     * Acceptance state of the disclaimer.
     **/
    didAcceptDisclaimer: boolean;
    /**
     * Set the acceptance state of the disclaimer.
     **/
    setDidAcceptDisclaimer: (accept: boolean) => void;
    /**
     * Trigger a regeneration of the last answer.
     **/
    regenerateLastAnswer: () => void;
}
export interface CreateChatOptions {
    debug?: boolean;
    projectKey: string;
    apiUrl?: string;
    persistChatHistory?: boolean;
    chatOptions?: MarkpromptOptions['chat'];
    storeKey?: string;
}
/**
 * Creates a chat store for a given project key.
 * Keeps track of messages by project key and thread id.
 *
 * @param projectKey - Markprompt project key
 * @param persistChatHistory - Should chat history be persisted in local storage?
 */
export declare const createChatStore: ({ chatOptions, debug, persistChatHistory, projectKey, storeKey, apiUrl, }: CreateChatOptions) => Omit<Omit<import("zustand").StoreApi<ChatStoreState>, "setState"> & {
    setState(nextStateOrUpdater: ChatStoreState | Partial<ChatStoreState> | ((state: {
        projectKey: string;
        apiUrl?: string | undefined;
        abort?: (() => void) | undefined;
        threadId?: string | undefined;
        setThreadId: (threadId: string) => void;
        selectThread: (threadId?: string) => void;
        messages: {
            id: ReturnType<typeof crypto.randomUUID>;
            state: ChatLoadingState;
            name?: string | undefined;
            error?: {
                name: string;
                message: string;
                stack?: string | undefined;
                cause?: unknown;
            } | undefined;
            role?: "user" | "assistant" | "tool" | "system" | undefined;
            content?: string | null | undefined;
            references?: {
                file: {
                    title?: string | undefined;
                    path: string;
                    meta?: object | undefined;
                    source: {
                        type: import("@markprompt/core").SourceType;
                        data?: {
                            url?: string | undefined;
                            domain?: string | undefined;
                        } | undefined;
                    };
                };
                meta?: {
                    leadHeading?: {
                        id?: string | undefined;
                        depth?: number | undefined;
                        value?: string | undefined;
                        slug?: string | undefined;
                    } | undefined;
                } | undefined;
            }[] | undefined;
            function_call?: {
                arguments?: string | undefined;
                name?: string | undefined;
            } | undefined;
            tool_calls?: {
                index: number;
                id?: string | undefined;
                function?: {
                    arguments?: string | undefined;
                    name?: string | undefined;
                } | undefined;
                type?: "function" | undefined;
            }[] | undefined;
            messageId?: string | undefined;
        }[];
        setMessages: (messages: ChatViewMessage[]) => void;
        setMessageById: (id: string, next: Partial<ChatViewMessage>) => void;
        setMessageByIndex: (index: number, next: Partial<ChatViewMessage>) => void;
        setToolCallById: (toolCallId: string, next: Partial<ToolCall>) => void;
        threadIdsByProjectKey: {
            [x: string]: string[];
        };
        messagesByThreadId: {
            [x: string]: {
                lastUpdated: string;
                messages: {
                    id: ReturnType<typeof crypto.randomUUID>;
                    state: ChatLoadingState;
                    name?: string | undefined;
                    error?: {
                        name: string;
                        message: string;
                        stack?: string | undefined;
                        cause?: unknown;
                    } | undefined;
                    role?: "user" | "assistant" | "tool" | "system" | undefined;
                    content?: string | null | undefined;
                    references?: {
                        file: {
                            title?: string | undefined;
                            path: string;
                            meta?: object | undefined;
                            source: {
                                type: import("@markprompt/core").SourceType;
                                data?: {
                                    url?: string | undefined;
                                    domain?: string | undefined;
                                } | undefined;
                            };
                        };
                        meta?: {
                            leadHeading?: {
                                id?: string | undefined;
                                depth?: number | undefined;
                                value?: string | undefined;
                                slug?: string | undefined;
                            } | undefined;
                        } | undefined;
                    }[] | undefined;
                    function_call?: {
                        arguments?: string | undefined;
                        name?: string | undefined;
                    } | undefined;
                    tool_calls?: {
                        index: number;
                        id?: string | undefined;
                        function?: {
                            arguments?: string | undefined;
                            name?: string | undefined;
                        } | undefined;
                        type?: "function" | undefined;
                    }[] | undefined;
                    messageId?: string | undefined;
                }[];
            };
        };
        toolCallsByToolCallId: {
            [x: string]: {
                status: 'loading' | 'done' | 'error';
                error?: string | undefined;
                result?: string | undefined;
            };
        };
        submitChat: (messages: SubmitChatMessage[]) => void;
        submitToolCalls: (message: ChatViewMessage) => Promise<void>;
        options?: {
            assistantId?: string | undefined;
            assistantVersionId?: string | undefined;
            systemPrompt?: string | undefined;
            context?: any;
            model?: import("@markprompt/core").OpenAIModelId | undefined;
            policiesOptions?: {
                enabled?: boolean | undefined;
                useAll?: boolean | undefined;
                ids?: string[] | undefined;
            } | undefined;
            retrievalOptions?: {
                enabled?: boolean | undefined;
                useAll?: boolean | undefined;
                ids?: string[] | undefined;
            } | undefined;
            outputFormat?: "html" | "markdown" | "slack" | undefined;
            jsonOutput?: boolean | undefined;
            redact?: boolean | undefined;
            temperature?: number | undefined;
            topP?: number | undefined;
            frequencyPenalty?: number | undefined;
            presencePenalty?: number | undefined;
            maxTokens?: number | undefined;
            sectionsMatchCount?: number | undefined;
            sectionsMatchThreshold?: number | undefined;
            threadId?: string | undefined;
            toolChoice?: "none" | "auto" | "required" | {
                function: {
                    name: string;
                };
                type: "function";
            } | undefined;
            doNotInjectContext?: boolean | undefined;
            allowFollowUpQuestions?: boolean | undefined;
            excludeFromInsights?: boolean | undefined;
            debug?: boolean | undefined;
            iDontKnowMessage?: string | undefined;
            stream?: boolean | undefined;
            tools?: {
                tool: {
                    function: {
                        name: string;
                        description?: string | undefined;
                        parameters?: {
                            [x: string]: unknown;
                        } | undefined;
                    };
                    type: "function";
                };
                call: (args: string) => Promise<string>;
                requireConfirmation?: boolean | undefined;
                showDefaultAutoTriggerMessage?: boolean | undefined;
            }[] | undefined;
            ToolCallsConfirmation?: ((props: ConfirmationProps) => JSX.Element) | undefined;
            enabled?: boolean | undefined;
            label?: string | undefined;
            title?: string | undefined;
            tabLabel?: string | undefined;
            placeholder?: string | undefined;
            buttonLabel?: string | undefined;
            errorText?: import("react").ComponentType<{
                error: Error;
            }> | undefined;
            showCopy?: boolean | undefined;
            history?: boolean | undefined;
            defaultView?: {
                message?: string | import("react").ComponentType | undefined;
                promptsHeading?: string | undefined;
                prompts?: string[] | undefined;
            } | undefined;
            disclaimerView?: {
                message: string | import("react").ComponentType;
                cta?: string | undefined;
            } | undefined;
            avatars?: {
                visible?: boolean | undefined;
                user?: string | import("react").ComponentType<{
                    className: string;
                }> | undefined;
                assistant?: string | import("react").ComponentType<{
                    className: string;
                }> | undefined;
            } | undefined;
        } | undefined;
        setOptions: (options: UserConfigurableOptions) => void;
        didAcceptDisclaimerByProjectKey: {
            [x: string]: boolean;
        };
        didAcceptDisclaimer: boolean;
        setDidAcceptDisclaimer: (accept: boolean) => void;
        regenerateLastAnswer: () => void;
    }) => void), shouldReplace?: boolean | undefined): void;
}, "persist"> & {
    persist: {
        setOptions: (options: Partial<import("zustand/middleware").PersistOptions<ChatStoreState, unknown>>) => void;
        clearStorage: () => void;
        rehydrate: () => void | Promise<void>;
        hasHydrated: () => boolean;
        onHydrate: (fn: (state: ChatStoreState) => void) => () => void;
        onFinishHydration: (fn: (state: ChatStoreState) => void) => () => void;
        getOptions: () => Partial<import("zustand/middleware").PersistOptions<ChatStoreState, unknown>>;
    };
};
export declare const ChatContext: import("react").Context<(Omit<Omit<import("zustand").StoreApi<ChatStoreState>, "setState"> & {
    setState(nextStateOrUpdater: ChatStoreState | Partial<ChatStoreState> | ((state: {
        projectKey: string;
        apiUrl?: string | undefined;
        abort?: (() => void) | undefined;
        threadId?: string | undefined;
        setThreadId: (threadId: string) => void;
        selectThread: (threadId?: string) => void;
        messages: {
            id: ReturnType<typeof crypto.randomUUID>;
            state: ChatLoadingState;
            name?: string | undefined;
            error?: {
                name: string;
                message: string;
                stack?: string | undefined;
                cause?: unknown;
            } | undefined;
            role?: "user" | "assistant" | "tool" | "system" | undefined;
            content?: string | null | undefined;
            references?: {
                file: {
                    title?: string | undefined;
                    path: string;
                    meta?: object | undefined;
                    source: {
                        type: import("@markprompt/core").SourceType;
                        data?: {
                            url?: string | undefined;
                            domain?: string | undefined;
                        } | undefined;
                    };
                };
                meta?: {
                    leadHeading?: {
                        id?: string | undefined;
                        depth?: number | undefined;
                        value?: string | undefined;
                        slug?: string | undefined;
                    } | undefined;
                } | undefined;
            }[] | undefined;
            function_call?: {
                arguments?: string | undefined;
                name?: string | undefined;
            } | undefined;
            tool_calls?: {
                index: number;
                id?: string | undefined;
                function?: {
                    arguments?: string | undefined;
                    name?: string | undefined;
                } | undefined;
                type?: "function" | undefined;
            }[] | undefined;
            messageId?: string | undefined;
        }[];
        setMessages: (messages: ChatViewMessage[]) => void;
        setMessageById: (id: string, next: Partial<ChatViewMessage>) => void;
        setMessageByIndex: (index: number, next: Partial<ChatViewMessage>) => void;
        setToolCallById: (toolCallId: string, next: Partial<ToolCall>) => void;
        threadIdsByProjectKey: {
            [x: string]: string[];
        };
        messagesByThreadId: {
            [x: string]: {
                lastUpdated: string;
                messages: {
                    id: ReturnType<typeof crypto.randomUUID>;
                    state: ChatLoadingState;
                    name?: string | undefined;
                    error?: {
                        name: string;
                        message: string;
                        stack?: string | undefined;
                        cause?: unknown;
                    } | undefined;
                    role?: "user" | "assistant" | "tool" | "system" | undefined;
                    content?: string | null | undefined;
                    references?: {
                        file: {
                            title?: string | undefined;
                            path: string;
                            meta?: object | undefined;
                            source: {
                                type: import("@markprompt/core").SourceType;
                                data?: {
                                    url?: string | undefined;
                                    domain?: string | undefined;
                                } | undefined;
                            };
                        };
                        meta?: {
                            leadHeading?: {
                                id?: string | undefined;
                                depth?: number | undefined;
                                value?: string | undefined;
                                slug?: string | undefined;
                            } | undefined;
                        } | undefined;
                    }[] | undefined;
                    function_call?: {
                        arguments?: string | undefined;
                        name?: string | undefined;
                    } | undefined;
                    tool_calls?: {
                        index: number;
                        id?: string | undefined;
                        function?: {
                            arguments?: string | undefined;
                            name?: string | undefined;
                        } | undefined;
                        type?: "function" | undefined;
                    }[] | undefined;
                    messageId?: string | undefined;
                }[];
            };
        };
        toolCallsByToolCallId: {
            [x: string]: {
                status: 'loading' | 'done' | 'error';
                error?: string | undefined;
                result?: string | undefined;
            };
        };
        submitChat: (messages: SubmitChatMessage[]) => void;
        submitToolCalls: (message: ChatViewMessage) => Promise<void>;
        options?: {
            assistantId?: string | undefined;
            assistantVersionId?: string | undefined;
            systemPrompt?: string | undefined;
            context?: any;
            model?: import("@markprompt/core").OpenAIModelId | undefined;
            policiesOptions?: {
                enabled?: boolean | undefined;
                useAll?: boolean | undefined;
                ids?: string[] | undefined;
            } | undefined;
            retrievalOptions?: {
                enabled?: boolean | undefined;
                useAll?: boolean | undefined;
                ids?: string[] | undefined;
            } | undefined;
            outputFormat?: "html" | "markdown" | "slack" | undefined;
            jsonOutput?: boolean | undefined;
            redact?: boolean | undefined;
            temperature?: number | undefined;
            topP?: number | undefined;
            frequencyPenalty?: number | undefined;
            presencePenalty?: number | undefined;
            maxTokens?: number | undefined;
            sectionsMatchCount?: number | undefined;
            sectionsMatchThreshold?: number | undefined;
            threadId?: string | undefined;
            toolChoice?: "none" | "auto" | "required" | {
                function: {
                    name: string;
                };
                type: "function";
            } | undefined;
            doNotInjectContext?: boolean | undefined;
            allowFollowUpQuestions?: boolean | undefined;
            excludeFromInsights?: boolean | undefined;
            debug?: boolean | undefined;
            iDontKnowMessage?: string | undefined;
            stream?: boolean | undefined;
            tools?: {
                tool: {
                    function: {
                        name: string;
                        description?: string | undefined;
                        parameters?: {
                            [x: string]: unknown;
                        } | undefined;
                    };
                    type: "function";
                };
                call: (args: string) => Promise<string>;
                requireConfirmation?: boolean | undefined;
                showDefaultAutoTriggerMessage?: boolean | undefined;
            }[] | undefined;
            ToolCallsConfirmation?: ((props: ConfirmationProps) => JSX.Element) | undefined;
            enabled?: boolean | undefined;
            label?: string | undefined;
            title?: string | undefined;
            tabLabel?: string | undefined;
            placeholder?: string | undefined;
            buttonLabel?: string | undefined;
            errorText?: import("react").ComponentType<{
                error: Error;
            }> | undefined;
            showCopy?: boolean | undefined;
            history?: boolean | undefined;
            defaultView?: {
                message?: string | import("react").ComponentType | undefined;
                promptsHeading?: string | undefined;
                prompts?: string[] | undefined;
            } | undefined;
            disclaimerView?: {
                message: string | import("react").ComponentType;
                cta?: string | undefined;
            } | undefined;
            avatars?: {
                visible?: boolean | undefined;
                user?: string | import("react").ComponentType<{
                    className: string;
                }> | undefined;
                assistant?: string | import("react").ComponentType<{
                    className: string;
                }> | undefined;
            } | undefined;
        } | undefined;
        setOptions: (options: UserConfigurableOptions) => void;
        didAcceptDisclaimerByProjectKey: {
            [x: string]: boolean;
        };
        didAcceptDisclaimer: boolean;
        setDidAcceptDisclaimer: (accept: boolean) => void;
        regenerateLastAnswer: () => void;
    }) => void), shouldReplace?: boolean | undefined): void;
}, "persist"> & {
    persist: {
        setOptions: (options: Partial<import("zustand/middleware").PersistOptions<ChatStoreState, unknown>>) => void;
        clearStorage: () => void;
        rehydrate: () => void | Promise<void>;
        hasHydrated: () => boolean;
        onHydrate: (fn: (state: ChatStoreState) => void) => () => void;
        onFinishHydration: (fn: (state: ChatStoreState) => void) => () => void;
        getOptions: () => Partial<import("zustand/middleware").PersistOptions<ChatStoreState, unknown>>;
    };
}) | null>;
interface ChatProviderProps {
    chatOptions?: MarkpromptOptions['chat'];
    children: ReactNode;
    debug?: boolean;
    projectKey: string;
    storeKey?: string;
    apiUrl?: string;
}
export declare function ChatProvider(props: ChatProviderProps): JSX.Element;
export declare function useChatStore<T>(selector: (state: ChatStoreState) => T): T;
export declare const selectProjectThreads: (state: ChatStoreState) => [
    threadId: string,
    {
        lastUpdated: string;
        messages: ChatViewMessage[];
    }
][];
export {};
//# sourceMappingURL=store.d.ts.map