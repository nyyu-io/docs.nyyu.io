import { Fragment as _Fragment, jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { AccessibleIcon } from '@radix-ui/react-accessible-icon';
import * as Dialog from '@radix-ui/react-dialog';
import { forwardRef, useEffect, useRef, memo, useCallback, useState, } from 'react';
import Markdown from 'react-markdown';
import { mergeRefs } from 'react-merge-refs';
import TextareaAutoSize from 'react-textarea-autosize';
import remarkGfm from 'remark-gfm';
import { ConditionalVisuallyHidden } from './ConditionalWrap.js';
import { CheckIcon, ClipboardIcon } from '../icons.js';
/**
 * The Markprompt context provider and dialog root.
 */
function Root(props) {
    const { children, display = 'dialog', defaultOpen, modal, onOpenChange, open, } = props;
    if (display === 'plain') {
        return _jsx(_Fragment, { children: children });
    }
    return (_jsx(DialogRootWithAbort, { defaultOpen: defaultOpen, modal: modal, onOpenChange: onOpenChange, open: open, children: children }));
}
function DialogRootWithAbort(props) {
    const { modal = true, ...rest } = props;
    return (_jsx(Dialog.Root, { ...rest, modal: modal, children: props.children }));
}
/**
 * A button to open the Markprompt dialog.
 */
const DialogTrigger = forwardRef((props, ref) => {
    return _jsx(Dialog.Trigger, { ref: ref, ...props });
});
DialogTrigger.displayName = 'Markprompt.DialogTrigger';
/**
 * The Markprompt dialog portal.
 */
function Portal(props) {
    return _jsx(Dialog.Portal, { ...props });
}
Portal.displayName = 'Markprompt.Portal';
/**
 * The Markprompt dialog overlay.
 */
const Overlay = forwardRef((props, ref) => {
    return _jsx(Dialog.Overlay, { ref: ref, ...props });
});
Overlay.displayName = 'Markprompt.Overlay';
/**
 * The Markprompt dialog content.
 */
const Content = forwardRef(function Content(props, ref) {
    return (_jsx(Dialog.Content, { ...props, ref: ref, children: props.children }));
});
Content.displayName = 'Markprompt.Content';
/**
 * The Markprompt plain content.
 */
const PlainContent = forwardRef(function PlainContent(props, ref) {
    return (_jsx("div", { ...props, ref: ref, children: props.children }));
});
PlainContent.displayName = 'Markprompt.PlainContent';
/**
 * A button to close the Markprompt dialog and abort an ongoing request.
 */
const Close = forwardRef(function Close(props, ref) {
    return _jsx(Dialog.Close, { ...props, ref: ref });
});
Close.displayName = 'Markprompt.Close';
const Title = forwardRef((props, ref) => {
    const { hide, ...rest } = props;
    return (_jsx(ConditionalVisuallyHidden, { hide: hide, asChild: true, children: _jsx(Dialog.Title, { ...rest, ref: ref }) }));
});
Title.displayName = 'Markprompt.Title';
/**
 * A visually hidden aria description.
 */
const Description = forwardRef((props, ref) => {
    const { hide, ...rest } = props;
    return (_jsx(ConditionalVisuallyHidden, { hide: hide, asChild: true, children: _jsx(Dialog.Description, { ...rest, ref: ref }) }));
});
Description.displayName = 'Markprompt.Description';
/**
 * A form which, when submitted, submits the current prompt.
 */
const Form = forwardRef(function Form(props, ref) {
    return _jsx("form", { ...props, ref: ref });
});
/**
 * The Markprompt input prompt. User input will update the prompt in the Markprompt context.
 */
const Prompt = forwardRef(function Prompt(props, ref) {
    const { autoCapitalize = 'none', autoComplete = 'off', autoCorrect = 'off', autoFocus = true, label, buttonLabel = 'Send', labelClassName, textAreaContainerClassName, sendButtonClassName, placeholder, spellCheck = false, type = 'search', showSubmitButton = true, isLoading, Icon, name, className, minRows, submitOnEnter, onSubmit, onKeyDown, ...rest } = props;
    const handleKeyDown = useCallback((event) => {
        if (type === 'search') {
            onKeyDown?.(event);
            return;
        }
        if (event.key === 'Enter' && !event.shiftKey) {
            if (submitOnEnter !== false) {
                event.preventDefault();
                onSubmit?.(event);
            }
            else if (event.metaKey || event.ctrlKey) {
                event.preventDefault();
                onSubmit?.(event);
            }
        }
    }, [onKeyDown, onSubmit, submitOnEnter, type]);
    const Comp = type === 'search' ? 'input' : TextareaAutoSize;
    return (_jsxs(_Fragment, { children: [label && (_jsx("label", { htmlFor: name, className: labelClassName, children: label })), _jsx("div", { className: textAreaContainerClassName, children: _jsx(Comp, { ...rest, id: name, name: name, type: type, minRows: minRows, placeholder: placeholder, ref: ref, autoCapitalize: autoCapitalize, autoComplete: autoComplete, autoCorrect: autoCorrect, autoFocus: autoFocus, spellCheck: spellCheck, className: className, draggable: false, style: { resize: 'none', height: '100%' }, onKeyDown: handleKeyDown }) }), showSubmitButton && (_jsxs("button", { className: sendButtonClassName, type: "submit", "data-variant": "primary", disabled: isLoading ||
                    (rest.value?.trim()?.length === 0 && !isLoading), children: [buttonLabel, Icon] }))] }));
});
Prompt.displayName = 'Markprompt.Prompt';
function CopyContentButton(props) {
    const { content, className } = props;
    const [didJustCopy, setDidJustCopy] = useState(false);
    const handleClick = () => {
        navigator.clipboard.writeText(content);
        setDidJustCopy(true);
        setTimeout(() => {
            setDidJustCopy(false);
        }, 2000);
    };
    return (_jsx("button", { className: className, style: { animationDelay: '100ms' }, "data-active": false, onClick: handleClick, children: _jsx(AccessibleIcon, { label: didJustCopy ? 'copied' : 'copy', children: _jsxs("div", { style: { position: 'relative' }, children: [_jsx(ClipboardIcon, { style: { opacity: didJustCopy ? 0 : 1 }, width: 16, height: 16, strokeWidth: 2 }), _jsx("div", { style: { position: 'absolute', inset: 0 }, children: _jsx(CheckIcon, { style: { opacity: didJustCopy ? 1 : 0 }, width: 16, height: 16, strokeWidth: 2 }) })] }) }) }));
}
CopyContentButton.displayName = 'Markprompt.CopyContentButton';
function HighlightedCode(props) {
    const { children, className, state, ...rest } = props;
    useEffect(() => {
        if (state === 'done') {
            // If highlight.js script/css tags were added globally,
            // we can syntax highlight. This trick allows us to provide
            // syntax highlighting without imposing a large extra
            // package as part of the markprompt-js bundle.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            globalThis.hljs?.highlightAll();
        }
    }, [children, state]);
    return (_jsx("pre", { style: { overflow: 'auto' }, ...rest, className: className, children: children }));
}
/**
 * Render the markdown answer from the Markprompt API.
 */
function Answer(props) {
    const { answer, state, copyButtonClassName, remarkPlugins = [remarkGfm], linkAs, ...rest } = props;
    const LinkComponent = linkAs ?? 'a';
    return (_jsx(Markdown, { ...rest, remarkPlugins: remarkPlugins, components: {
            a: (props) => _jsx(LinkComponent, { ...props }),
            pre: (props) => {
                const { children, className, ...rest } = props;
                return (_jsxs("div", { style: {
                        position: 'relative',
                    }, children: [_jsx("div", { style: {
                                position: 'absolute',
                                top: '0.5rem',
                                right: '0.5rem',
                                border: 0,
                            }, children: _jsx(CopyContentButton, { className: copyButtonClassName, content: children &&
                                    typeof children === 'object' &&
                                    'props' in children
                                    ? children.props.children
                                    : '' }) }), _jsx(HighlightedCode, { ...rest, className: className, state: state, children: children })] }));
            },
        }, children: answer ?? '' }));
}
Answer.displayName = 'Markprompt.Answer';
/**
 * A component that automatically scrolls to the bottom.
 */
const AutoScroller = memo(forwardRef((props, ref) => {
    const { 
    // eslint-disable-next-line react/prop-types
    autoScroll = true, 
    // eslint-disable-next-line react/prop-types
    scrollBehavior = 'smooth', 
    // eslint-disable-next-line react/prop-types
    scrollTrigger, 
    // eslint-disable-next-line react/prop-types
    discreteScrollTrigger, ...rest } = props;
    const localRef = useRef(null);
    const scrollLockOn = useRef(false);
    const didScrollOnce = useRef(false);
    const perhapsScroll = useCallback(() => {
        if (!localRef.current)
            return;
        if (!autoScroll)
            return;
        if (scrollLockOn.current)
            return;
        localRef.current.scrollTo({
            top: localRef.current.scrollHeight,
            behavior: didScrollOnce.current ? scrollBehavior : 'instant',
        });
        didScrollOnce.current = true;
    }, [autoScroll, scrollBehavior]);
    useEffect(() => {
        // When scrollTrigger changes, potentially trigger scroll.
        // Scroll immediately (e.g. when opening an existing chat), and
        // also after a small delay in case other DOM nodes (such as references)
        // are appended.
        perhapsScroll();
        setTimeout(perhapsScroll, 400);
    }, [perhapsScroll, scrollTrigger]);
    useEffect(() => {
        // When discreteScrollTrigger changes (typically when a new message
        // is appended to the list of messages), reset the scroll lock, so
        // it can scroll down to the currently loading message.
        scrollLockOn.current = false;
        perhapsScroll();
        setTimeout(perhapsScroll, 400);
    }, [discreteScrollTrigger, perhapsScroll]);
    const handleScroll = () => {
        if (!localRef.current) {
            return;
        }
        const element = localRef.current;
        // Check if user has scrolled away from the bottom. Note that the
        // autoscroll may leave a pixel of space, so we give it a 10 pixel
        // buffer.
        const relativeScrollHeight = element.scrollHeight - element.scrollTop;
        if (Math.abs(relativeScrollHeight - element.clientHeight) > 10) {
            scrollLockOn.current = true;
        }
        else {
            scrollLockOn.current = false;
        }
    };
    return (_jsx("div", { ref: mergeRefs([ref, localRef]), ...rest, onScroll: handleScroll }));
}));
AutoScroller.displayName = 'Markprompt.AutoScroller';
/**
 * Render the references that Markprompt returns.
 */
const References = function References(props, ref) {
    const { RootComponent = 'ul', ReferenceComponent = 'li', references = [], } = props;
    return (_jsx(RootComponent, { ref: ref, children: references.map((reference, index) => {
            return (_jsx(_Fragment, { children: _jsx(ReferenceComponent, { reference: reference, index: index }, `${reference.file.path}-${index}`) }));
        }) }));
};
/**
 * Render the references that Markprompt returned.
 */
const ForwardedReferences = forwardRef(References);
ForwardedReferences.displayName = 'Markprompt.References';
const SearchResults = forwardRef((props, ref) => {
    const { as: Component = 'ul', label = 'Search results', SearchResultComponent = SearchResult, searchResults, searchOptions, headingClassName, ...rest } = props;
    return (_jsxs(Component, { ...rest, ref: ref, role: "listbox", id: "markprompt-search-results", tabIndex: 0, "aria-label": label, children: [searchResults.map((result, index) => {
                const id = `markprompt-result-${index}`;
                return (_jsx(SearchResultComponent, { id: id, index: index, role: "option", ...result }, id));
            }), searchOptions?.defaultView?.searches?.length &&
                searchOptions?.defaultView?.searchesHeading && (_jsx("div", { className: headingClassName, children: searchOptions.defaultView.searchesHeading })), searchOptions?.defaultView?.searches?.map((result, index) => {
                const adjustedIndex = index + searchResults.length;
                const id = `markprompt-result-${adjustedIndex}`;
                return (_jsx(SearchResultComponent, { id: id, index: adjustedIndex, role: "option", ...result }, id));
            })] }));
});
SearchResults.displayName = 'Markprompt.SearchResults';
const SearchResult = forwardRef((props, ref) => {
    const { title, href, ...rest } = props;
    return (_jsx("li", { ref: ref, ...rest, children: _jsx("a", { href: href, children: title }) }));
});
SearchResult.displayName = 'Markprompt.SearchResult';
function ErrorMessage(props) {
    const { className, children } = props;
    return (_jsx("div", { className: className, children: _jsx("p", { children: children }) }));
}
ErrorMessage.displayName = 'Markprompt.ErrorMessage';
export { Answer, AutoScroller, Close, Content, CopyContentButton, Description, DialogTrigger, ErrorMessage, Form, Overlay, PlainContent, Portal, Prompt, ForwardedReferences as References, Root, SearchResult, SearchResults, Title, };
//# sourceMappingURL=headless.js.map